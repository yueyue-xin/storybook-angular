---
description: "Component analysis and metadata extraction for story generation"
globs: ["**/*.component.ts"]
alwaysApply: false
---

# Component Analysis Rules

## Purpose
Analyze Angular component structure, dependencies, and metadata as the foundation for Storybook story generation.

## Trigger
- User requests: "Create story for [component-name]"
- User requests: "Generate stories for [component-path]"

---

## Analysis Workflow

### 1. Extract Component Metadata

#### 1.1 Basic Information
```typescript
// Extract from @Component decorator
@Component({
  selector: 'app-user-profile',
  standalone: true,  // Angular 19 default unless explicitly false
  templateUrl: './user-profile.component.html'
})
export class UserProfileComponent {}

// Output:
// - componentName: 'UserProfileComponent'
// - selector: 'app-user-profile'
// - isStandalone: true (default in Angular 19)
// - templatePath: './user-profile.component.html'
```

**Standalone Detection Logic**:
- Angular 19+: `standalone = true` by default
- Only `false` if explicitly declared: `standalone: false`

#### 1.2 @Input() Properties
```typescript
// Extract all @Input() decorators with types
export class DataGridComponent {
  @Input({ required: true }) config!: GridConfig;
  @Input() columns: Column[] = [];
  @Input('rowHeight') height: number = 40;
}

// Output structure:
interface InputProperty {
  name: string;
  type: string;
  required: boolean;
  defaultValue?: string;
  importPath?: string;  // From component's import statements
}
```

#### 1.3 @Output() Events
```typescript
// Extract all @Output() decorators
export class FormComponent {
  @Output() submit = new EventEmitter<FormData>();
  @Output('valueChange') onChange = new EventEmitter<string>();
}

// Output structure:
interface OutputEvent {
  name: string;
  eventType: string;
  hasAlias: boolean;
}
```

---

### 2. Dependency Injection Analysis

#### 2.1 Extract Injected Services
```typescript
// Method 1: Constructor injection (traditional)
constructor(
  private http: HttpClient,
  private store: Store,
  private transloco: TranslocoService,
  @Inject(CONFIG_TOKEN) private config: AppConfig
) {}

// Method 2: inject() function (modern Angular - standalone friendly)
import { inject } from '@angular/core';

export class MyComponent {
  private http = inject(HttpClient);
  private store = inject(Store);
  transloco = inject(TranslocoService);
  config = inject(CONFIG_TOKEN);
}

// Detection strategy:
// 1. Parse constructor: constructor\([^)]*ServiceName[^)]*\)
// 2. Parse inject(): inject\(ServiceName\)
// Both patterns should be detected for complete analysis

// Output:
interface InjectedDependency {
  parameterName: string;
  typeName: string;
  isToken: boolean;
  injectionMethod: 'constructor' | 'inject';
}
```

#### 2.2 Service Classification
```typescript
// Check against global providers in @storybook-config/preview.ts
// Output:
interface ServiceClassification {
  globalServices: string[];      // ['TranslocoService', 'Store']
  needsLocalMock: string[];      // ['HttpClient', 'CustomService']
  useParameters: string[];       // ['TranslocoService', 'Store']
}
```

**Strategy**:
- `TranslocoService` → Use `parameters.translations`
- `Store` (@ngxs/store) → Use `parameters.storeSelectors/storeReducers`
- Other services → Create local mocks

---

### 3. Template Analysis

#### 3.1 Transloco Usage Detection
```typescript
// Pattern 1: Structural directive
<div *transloco="let t">{{ t('sdk.label.title') }}</div>

// Pattern 2: Pipe
<h1>{{ 'sdk.label.welcome' | transloco }}</h1>

// Pattern 3: Service method
this.transloco.translate('sdk.label.message');

// Output:
interface TranslocoUsage {
  usesTransloco: boolean;
  translationKeys: string[];
  patterns: ('directive' | 'pipe' | 'service')[];
}
```

#### 3.2 Dependency Detection
```typescript
// Detect required modules based on template content
const patterns = {
  ClarityModule: /<clr-|<cds-|\[clr|\(clr/,
  CommonModule: /\*ngFor|\*ngIf|\*ngSwitch/,
  FormsModule: /\[(ngModel)\]|\[ngModel\]|\(ngModelChange\)/,
};

// Detect custom components (non-standard selectors)
// Pattern: <custom-component> or <app-component>
const customComponents = templateContent.match(/<([a-z]+-[a-z\-]+)/g);
// Filter out framework components (clr-, cds-, ng-)
```

#### 3.3 Pipe Detection
```typescript
// Extract all pipe usage: {{ value | pipeName }}
const pipeMatches = templateContent.match(/\|\s*(\w+)/g);
// Classify: built-in vs custom
// Built-in: date, json, uppercase, lowercase, currency, async
// Custom: needs import
```

---

### 4. Import Statement Extraction

```typescript
// Extract all import statements from component
import { GridConfig } from './grid-config.model';
import { Column } from '@app/shared/types';

// Build type-to-path mapping for mock generation
interface ImportStatement {
  symbols: string[];
  path: string;
  category: 'framework' | 'local' | 'external';
}

// Output: Map<typeName, importPath>
// Used by type-safe-mocks.mdc to generate accurate imports
```

---

### 5. Component Metadata Assessment

```typescript
// Analyze component characteristics
interface ComponentMetadata {
  hasInteractions: boolean;      // Has buttons, forms, clickable elements
  hasDataVariations: boolean;    // Has lists, tables, data display
  hasStateVariations: boolean;   // Has loading, error, empty states
  complexity: 'simple' | 'medium' | 'complex';
}

// Criteria:
// - simple: < 3 @Input(), no services, basic template
// - medium: 3-7 @Input(), 1-2 services, moderate template
// - complex: > 7 @Input(), multiple services, complex template
```

---

## Output Structure

```typescript
interface ComponentAnalysis {
  // Basic
  componentName: string;
  selector: string;
  isStandalone: boolean;
  filePath: string;
  
  // Properties
  inputs: InputProperty[];
  outputs: OutputEvent[];
  
  // Dependencies
  injectedServices: InjectedDependency[];
  serviceClassification: ServiceClassification;
  
  // Template
  templateContent: string;
  translocoUsage: TranslocoUsage;
  dependencies: {
    needsClarityModule: boolean;
    needsCommonModule: boolean;
    needsFormsModule: boolean;
    customComponents: string[];
    pipesUsed: PipeUsage[];
  };
  
  // Imports
  typeImportMap: Map<string, string>;
  
  // Metadata
  metadata: ComponentMetadata;
}
```

---

## Integration with Other Rules

### Outputs to:
- `dependency-resolution.mdc` → dependency info
- `service-mocking-strategy.mdc` → service injection info
- `type-safe-mocks.mdc` → type definitions and import paths
- `transloco-integration.mdc` → translation keys
- `story-template-generation.mdc` → all metadata

### Error Handling:
- Component file not found → Terminate with error message
- Template file missing → Use inline template or skip template analysis
- Type resolution fails → Mark as `unknown`, pass to `error-handling-and-validation.mdc`
- Import path ambiguous → Use component's exact path, add TODO if uncertain

---

## Best Practices

1. **Preserve Original Paths**: Use component's exact import paths, don't modify
2. **Type Safety First**: Extract accurate types, use `unknown` over `any` when uncertain
3. **Context Preservation**: Keep metadata for downstream rules
4. **Non-Destructive**: Analysis should never modify source files
5. **Comprehensive**: Capture all information, even if partially incomplete

---

## Example Analysis Result

```typescript
// For UserProfileComponent with:
// - @Input() user: User
// - @Output() edit: EventEmitter<User>
// - injected: TranslocoService
// - template: uses *transloco, has button

{
  componentName: 'UserProfileComponent',
  isStandalone: true,
  inputs: [
    { name: 'user', type: 'User', required: true, importPath: '@app/models/user' }
  ],
  outputs: [
    { name: 'edit', eventType: 'User' }
  ],
  serviceClassification: {
    globalServices: ['TranslocoService'],
    useParameters: ['TranslocoService']
  },
  translocoUsage: {
    usesTransloco: true,
    translationKeys: ['profile.email', 'profile.edit']
  },
  metadata: {
    hasInteractions: true,
    complexity: 'simple'
  }
}
```

---

**Note**: This rule provides the foundation for all subsequent story generation rules. All downstream rules consume the `ComponentAnalysis` output.
