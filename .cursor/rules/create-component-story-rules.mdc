---
description: "Automatic story generation for Angular components with controls and interactions"
globs: ["**/*.component.ts", "**/*.stories.ts"]
alwaysApply: false
---

# 🎭 Component Story Auto-Generation Rules

## Auto-Generation Trigger

When user requests "Create story for [component-name]" or "Generate stories for [component-path]", automatically analyze the component and generate comprehensive stories.

## 🚀 Angular 19 Compatibility

**Important**: This rule is optimized for Angular 19, where components are **standalone by default**. A component is only considered non-standalone if it explicitly declares `standalone: false` in the component decorator.

## Analysis Steps

### Step 1: Component Analysis
Automatically detect and extract:
1. **@Input() properties** - for controls generation
2. **@Output() events** - for action handlers
3. **Interactive elements** - buttons, inputs, forms
4. **Component dependencies** - imports and providers
5. **Component type** - form, display, interactive, etc.
6. **Standalone status** - Angular 19 default is standalone, only non-standalone if `standalone: false` is explicitly declared
7. **Service dependencies** - analyze constructor and identify required services
8. **Translation usage** - detect *transloco="let t" and t() calls in template, extract translation keys for stories parameters

### Step 2: Non-Standalone Component Setup

> **Angular 19 Note**: This section only applies to components that explicitly declare `standalone: false`. By default, all Angular 19 components are standalone.

#### Component Type Detection
```typescript
// ✅ Angular 19: Components are standalone by default
// Only non-standalone if explicitly declared as standalone: false
const isStandalone = !componentSource.includes('standalone: false');

// Alternative detection method using component metadata
const isStandaloneFromMetadata = componentMetadata.standalone !== false;

// For non-standalone components, analyze required modules
if (!isStandalone) {
  // 1. Identify required Angular modules (CommonModule, ReactiveFormsModule, etc.)
  // 2. Identify required third-party modules (ClarityModule, TranslocoModule, etc.)
  // 3. Identify dependent components that need to be declared
}
```

#### Service Dependency Analysis
```typescript
// Analyze constructor parameters to identify service dependencies
const serviceDependencies = analyzeConstructorDependencies(component);

// Check .storybook-base/preview.ts for existing providers
const existingProviders = parsePreviewProviders('.storybook-base/preview.ts');

// Determine which services need mocking
const servicesToMock = serviceDependencies.filter(service => 
  !existingProviders.includes(service) && isGlobalSingleton(service)
);
```

#### Mock Service Generation (if needed)
For services not provided in preview.ts, create mock classes:

**Create .storybook-base/mock/[service-name].mock.ts:**
```typescript
// Example: .storybook-base/mock/format-service.mock.ts
export class MockFormatService {
  dateToAge(date: Date): string {
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    
    if (diffMins < 60) return `${diffMins}m`;
    if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h`;
    return `${Math.floor(diffMins / 1440)}d`;
  }
  
  // Add other required methods based on component usage
}
```

**Update .storybook-base/mock/index.ts:**
```typescript
export { MockFormatService } from './format-service.mock';
export { MockTranslocoService } from './transloco-service.mock';
// Export all mock services
```

**Update .storybook-base/preview.ts providers:**
```typescript
import { MockFormatService } from './mock';

const basePreview: Preview = {
  decorators: [
    applicationConfig({
      providers: [
        importProvidersFrom(BrowserAnimationsModule),
        importProvidersFrom(ClarityModule),
        // Add mock services as needed
        { provide: FormatService, useClass: MockFormatService },
        { provide: TranslocoService, useValue: mockTranslocoService },
      ],
    }),
    // ... existing decorators
  ],
};
```

#### Translation Key Analysis
Analyze component template for transloco usage and extract translation keys:

```typescript
// Parse template for transloco usage patterns
function analyzeTranslationKeys(templateContent: string): string[] {
  const translationKeys: string[] = [];
  
  // Pattern 1: t('key') function calls
  const tFunctionPattern = /t\(['"`](.*?)['"`]\)/g;
  let match;
  while ((match = tFunctionPattern.exec(templateContent)) !== null) {
    translationKeys.push(match[1]);
  }
  
  // Pattern 2: {{ t('key') }} in interpolation
  const interpolationPattern = /\{\{\s*t\(['"`](.*?)['"`]\)\s*\}\}/g;
  while ((match = interpolationPattern.exec(templateContent)) !== null) {
    translationKeys.push(match[1]);
  }
  
  // Pattern 3: [placeholder]="t('key')" in attributes
  const attributePattern = /\[\w+\]=['"`].*?t\(['"`](.*?)['"`].*?['"`]/g;
  while ((match = attributePattern.exec(templateContent)) !== null) {
    translationKeys.push(match[1]);
  }
  
  return [...new Set(translationKeys)]; // Remove duplicates
}

// ✅ Check if component uses transloco
function hasTranslocoUsage(templateContent: string): boolean {
  // Check for *transloco directive
  const translocoDirectivePattern = /\*transloco\s*=\s*["']let\s+\w+["']/;
  
  // Check for t() function calls
  const tFunctionPattern = /t\(['"`][^'"`]*['"`]\)/;
  
  return translocoDirectivePattern.test(templateContent) || tFunctionPattern.test(templateContent);
}

// Example usage:
if (hasTranslocoUsage(templateContent)) {
  const detectedKeys = analyzeTranslationKeys(templateContent);
  // Generate translations only if transloco is used
  const translations = generateTranslationParameters(detectedKeys);
} else {
  // No transloco usage - skip translation parameters
  console.log('Component does not use transloco, skipping translation parameters');
}
```

#### Auto-Generate Translation Parameters
```typescript
// Generate translation mappings for stories
function generateTranslationParameters(translationKeys: string[]): Record<string, string> {
  const translations: Record<string, string> = {};
  
  translationKeys.forEach(key => {
    // Generate meaningful default translations based on key patterns
    translations[key] = generateDefaultTranslation(key);
  });
  
  return translations;
}

function generateDefaultTranslation(key: string): string {
  const keyMappings: Record<string, string> = {
    // Common patterns
    'sdk.label.type': 'Type',
    'sdk.label.reason': 'Reason',
    'sdk.label.age': 'Age',
    'sdk.label.from': 'Source',
    'sdk.label.message': 'Message',
    'sdk.text.filterPlaceholder': 'Filter...',
    'sdk.text.noItemFoundContaining_value': 'No items found containing "{{value}}"',
    
    // Component-specific
    'sdkUI.eventList.title': 'Events',
    'sdkUI.eventList.datagrid.noEvents': 'No events found',
    'sdkUI.eventList.datagrid.footer.eventList': 'Event list',
  };
  
  return keyMappings[key] || key.split('.').pop() || key;
}
```

### Step 3: Story Structure Generation

#### Base Story Template for Non-Standalone Components (Optimized)
```typescript
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { action } from '@storybook/addon-actions';
import { userEvent, within, expect } from '@storybook/test';

// Component and dependencies
import { [COMPONENT_NAME] } from './[component-file-name]';
import { CommonModule } from '@angular/common';
import { [REQUIRED_MODULES] } from '[module-paths]';
import { [DEPENDENT_COMPONENTS] } from '[component-paths]';

const meta: Meta<[COMPONENT_NAME]> = {
  title: 'Components/[COMPONENT_NAME]',
  component: [COMPONENT_NAME],
  decorators: [
    moduleMetadata({
      imports: [
        CommonModule,
        [REQUIRED_MODULES] // ClarityModule, TranslocoModule, etc.
      ],
      declarations: [
        [COMPONENT_NAME],
        [DEPENDENT_COMPONENTS] // FilterInputComponent, etc.
      ],
    }),
    // ✅ Define common template in decorator to avoid repetition
    (storyFn) => {
      const story = storyFn();
      return {
        ...story,
        template: `
          <div style="padding: 20px; max-width: 400px;">
            <[COMPONENT_SELECTOR]
              [GENERATED_INPUT_BINDINGS]
              [GENERATED_OUTPUT_BINDINGS]>
            </[COMPONENT_SELECTOR]>
          </div>
        `,
      };
    },
  ],
  parameters: {
    layout: 'centered',
    docs: {
      description: {
        component: '[AUTO_GENERATED_DESCRIPTION]'
      }
    }[CONDITIONAL_TRANSLATIONS_PARAMETER]
  },
  // tags: ['autodocs'], // ✅ Commented out by default - can be enabled per project
  argTypes: {
    [AUTO_GENERATED_ARG_TYPES]
  },
  args: {
    [AUTO_GENERATED_DEFAULT_ARGS]
  }
};

export default meta;
type Story = StoryObj<[COMPONENT_NAME]>;

// ✅ Most stories only need args (no render function)
export const Default: Story = {
  args: {
    [DEFAULT_ARGS]
  },
  play: async ({ canvasElement }) => {
    // ✅ Use universal element selection best practices
    const [MAIN_ELEMENT] = canvasElement.querySelector('[data-test-id="[COMPONENT_TEST_ID]"]');
    await expect([MAIN_ELEMENT]).toBeInTheDocument();
    
    // [AUTO_GENERATED_ELEMENT_TESTS]
  }
};

// ✅ For stories needing custom templates, override with render function
export const CustomLayoutStory: Story = {
  args: {
    [CUSTOM_ARGS]
  },
  render: (args) => ({
    props: args,
    template: `
      <div class="custom-wrapper">
        <p>Custom context description</p>
        <[COMPONENT_SELECTOR] [BINDINGS]></[COMPONENT_SELECTOR]>
      </div>
    `,
  }),
  play: async ({ canvasElement }) => {
    // Custom interactions
  }
};
```

#### Base Story Template for Standalone Components (Optimized)
```typescript
import type { Meta, StoryObj } from '@storybook/angular';
import { action } from '@storybook/addon-actions';
import { userEvent, within, expect } from '@storybook/test';
import { [COMPONENT_NAME] } from './[component-file-name]';

const meta: Meta<[COMPONENT_NAME]> = {
  title: 'Components/[COMPONENT_NAME]',
  component: [COMPONENT_NAME],
  decorators: [
    // ✅ Define common template in decorator for standalone components too
    (storyFn) => {
      const story = storyFn();
      return {
        ...story,
        template: `
          <div style="padding: 20px; max-width: 400px;">
            <[COMPONENT_SELECTOR]
              [GENERATED_INPUT_BINDINGS]
              [GENERATED_OUTPUT_BINDINGS]>
            </[COMPONENT_SELECTOR]>
          </div>
        `,
      };
    },
  ],
  parameters: {
    layout: 'centered',
    docs: {
      description: {
        component: '[AUTO_GENERATED_DESCRIPTION]'
      }
    }[CONDITIONAL_TRANSLATIONS_PARAMETER]
  },
  // tags: ['autodocs'], // ✅ Commented out by default - can be enabled per project
  argTypes: {
    [AUTO_GENERATED_ARG_TYPES]
  },
  args: {
    [AUTO_GENERATED_DEFAULT_ARGS]
  }
};

export default meta;
type Story = StoryObj<[COMPONENT_NAME]>;

// ✅ Most stories only need args (clean and simple)
export const Default: Story = {
  args: {
    [DEFAULT_PROP_VALUES]
  },
  play: async ({ canvasElement }) => {
    // ✅ Use universal element selection best practices
    const [MAIN_ELEMENT] = canvasElement.querySelector('[data-test-id="[COMPONENT_TEST_ID]"]');
    await expect([MAIN_ELEMENT]).toBeInTheDocument();
    
    // [AUTO_GENERATED_ELEMENT_TESTS]
  }
};
```

### Step 4: Input/Output Args Synchronization

#### Ensure Args Match Component Interface
```typescript
// AUTO-GENERATE args based on @Input() and @Output() properties
// For @Input() properties - create matching args with appropriate default values
// For @Output() events - create action handlers in args

interface ComponentInterface {
  // Extract from component TypeScript interface
  [INPUT_PROPERTY]: [INPUT_TYPE];
  [OUTPUT_EVENT]: EventEmitter<[OUTPUT_TYPE]>;
}

// Generate corresponding args
const componentArgs = {
  // Input properties with type-appropriate defaults
  [INPUT_PROPERTY]: [MOCK_DEFAULT_VALUE], // Matching the input type
  
  // Output events with action handlers
  [OUTPUT_EVENT]: action('[output-event-name]'),
};
```

#### Mock Data Generation Rules
```typescript
// Generate realistic mock data matching component data types
const mockDataGenerator = {
  // For complex objects, create realistic structures
  'Observable<NsEvent[]>': () => of([
    {
      eventType: 'Normal',
      reason: 'Started',
      createdOn: new Date(Date.now() - 5 * 60 * 1000),
      from: 'kubelet',
      message: 'Started container web-app',
      name: 'web-app-pod',
      namespace: 'default',
      type: 'Normal',
      uid: 'event-001',
    }
  ]),
  
  // For arrays, create multiple realistic items
  'User[]': () => [
    { id: 1, name: 'John Doe', email: 'john@example.com', role: 'admin' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'user' }
  ],
  
  // For primitives, use realistic defaults
  'string': () => 'Sample text',
  'number': () => 42,
  'boolean': () => false,
  'Date': () => new Date()
};
```

### Step 3: Input/Output Controls Generation

#### For @Input() Properties
```typescript
// Auto-generate based on TypeScript types
argTypes: {
  // String inputs
  [STRING_INPUT]: {
    control: 'text',
    description: '[AUTO_DESCRIPTION]',
    defaultValue: '[DEFAULT_VALUE]'
  },
  
  // Boolean inputs
  [BOOLEAN_INPUT]: {
    control: 'boolean',
    description: '[AUTO_DESCRIPTION]',
    defaultValue: false
  },
  
  // Number inputs
  [NUMBER_INPUT]: {
    control: { type: 'number', min: 0, max: 100 },
    description: '[AUTO_DESCRIPTION]',
    defaultValue: 0
  },
  
  // Enum/Union inputs
  [ENUM_INPUT]: {
    control: 'select',
    options: ['[OPTION_1]', '[OPTION_2]', '[OPTION_3]'],
    description: '[AUTO_DESCRIPTION]',
    defaultValue: '[FIRST_OPTION]'
  },
  
  // Array inputs
  [ARRAY_INPUT]: {
    control: 'object',
    description: '[AUTO_DESCRIPTION]',
    defaultValue: []
  },
  
  // Object inputs
  [OBJECT_INPUT]: {
    control: 'object',
    description: '[AUTO_DESCRIPTION]',
    defaultValue: {}
  }
}
```

#### For @Output() Events
```typescript
argTypes: {
  // Auto-generate action configurations for outputs
  [OUTPUT_EVENT]: {
    action: '[output-event-name]'
  },
  [CLICK_EVENT]: {
    action: 'clicked'
  },
  [CHANGE_EVENT]: {
    action: 'changed'
  },
  [SUBMIT_EVENT]: {
    action: 'submitted'
  }
},
args: {
  // Auto-generate action handlers for all outputs
  [OUTPUT_EVENT]: action('[output-event-name]'),
  [CLICK_EVENT]: action('clicked'),
  [CHANGE_EVENT]: action('changed'),
  [SUBMIT_EVENT]: action('submitted')
}
```

### Step 4: HTML Template Analysis & Interactive Stories Generation

#### HTML Element Detection Rules
Analyze the component's HTML template to detect interactive elements:

**Button Elements Detection:**
- `<button>` tags
- `<clr-button>` Clarity buttons  
- `[role="button"]` elements
- `<input type="button|submit|reset">`
- Elements with `(click)` handlers

**Input Elements Detection:**
- `<input>` tags (all types)
- `<textarea>` elements
- `<select>` dropdowns
- `<clr-input>`, `<clr-textarea>`, `<clr-select>` Clarity form controls
- `<clr-checkbox>`, `<clr-radio>` Clarity form options
- `<clr-datepicker>`, `<clr-combobox>` specialized Clarity inputs

**Form Elements Detection:**
- `<form>` containers
- `<clr-form>` Clarity forms
- Elements with `ngModel` or `formControl` directives

#### Auto-Generated Stories Based on HTML Analysis

**For Each Button Element Found:**
```typescript
export const ButtonInteractions: Story = {
  ...Default,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Find all button elements
    const buttons = canvas.getAllByRole('button');
    const primaryButton = buttons[0]; // First button
    const secondaryButton = buttons[1]; // Second button (if exists)
    
    // Test primary button
    if (primaryButton instanceof HTMLButtonElement && !primaryButton.disabled) {
    await userEvent.click(primaryButton);
    await expect(primaryButton).toBeInTheDocument();
    }
    
    // Test secondary button if exists
    if (secondaryButton instanceof HTMLButtonElement && !secondaryButton.disabled) {
      await userEvent.click(secondaryButton);
    }
    
    // Test disabled state (if button has disabled property)
    if (primaryButton.hasAttribute('disabled')) {
      await expect(primaryButton).toBeDisabled();
    }
  }
};

export const TranslocoSafeInteractions: Story = {
  ...Default,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // ✅ Correct - Use structural selectors for transloco content
    const titleElement = canvasElement.querySelector('h4'); // Title by element type
    await expect(titleElement).toBeInTheDocument();
    await expect(titleElement?.textContent).toBeTruthy(); // Check content exists, don't check specific text
    
    // ✅ Correct - Use data-test-id with proper CSS selector
    const dataGrid = canvasElement.querySelector('[data-test-id="event-list"]');
    await expect(dataGrid).toBeInTheDocument();
    
    // ✅ Correct - Use semantic roles when available
    const searchInput = canvas.getByRole('textbox'); // For filter input
    if (searchInput instanceof HTMLInputElement) {
      await userEvent.type(searchInput, 'test search');
      await expect(searchInput).toHaveValue('test search');
    }
    
    // ✅ Correct - Use element structure for Clarity components
    const clarityDatagrid = canvasElement.querySelector('clr-datagrid');
    await expect(clarityDatagrid).toBeInTheDocument();
    
    // ✅ Correct - Use column structure instead of translated text
    const columns = canvasElement.querySelectorAll('clr-dg-column');
    await expect(columns.length).toBeGreaterThan(0);
  }
};

export const AllButtonStates: Story = {
  ...Default,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const buttons = canvas.getAllByRole('button');
    
    for (const button of buttons) {
      const buttonText = button.textContent || button.getAttribute('aria-label') || 'Button';
      
      // Test each button with type safety
      if (button instanceof HTMLButtonElement && !button.disabled) {
        await userEvent.click(button);
        console.log(`Clicked: ${buttonText}`);
      }
    }
  }
};
```

**For Each Input Element Found:**
```typescript
export const InputInteractions: Story = {
  ...Default,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Text inputs
    const textInputs = canvas.queryAllByRole('textbox');
    for (const input of textInputs) {
      const label = input.getAttribute('aria-label') || input.getAttribute('placeholder') || 'input';
      await userEvent.clear(input);
      await userEvent.type(input, `Test ${label}`);
      await expect(input).toHaveValue(`Test ${label}`);
    }
    
    // Number inputs  
    const numberInputs = canvas.queryAllByRole('spinbutton');
    for (const input of numberInputs) {
      await userEvent.clear(input);
      await userEvent.type(input, '123');
      await expect(input).toHaveValue('123');
    }
    
    // Checkboxes
    const checkboxes = canvas.queryAllByRole('checkbox');
    for (const checkbox of checkboxes) {
      await userEvent.click(checkbox);
      await expect(checkbox).toBeChecked();
    }
    
    // Radio buttons
    const radios = canvas.queryAllByRole('radio');
    if (radios.length > 0) {
      await userEvent.click(radios[0]);
      await expect(radios[0]).toBeChecked();
    }
    
    // Select dropdowns
    const selects = canvas.queryAllByRole('combobox');
    for (const select of selects) {
      await userEvent.click(select);
      // Select first option if available
      const options = canvas.queryAllByRole('option');
      if (options.length > 0) {
        await userEvent.click(options[0]);
      }
    }
  }
};

export const FormValidation: Story = {
  ...Default,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Test required field validation
    const requiredInputs = canvas.queryAllByRole('textbox');
    for (const input of requiredInputs) {
      if (input.hasAttribute('required') || input.getAttribute('aria-required') === 'true') {
        await userEvent.clear(input);
        await userEvent.tab();
        
        // Check for validation message
        const validationMessage = canvas.queryByText(/required/i);
        if (validationMessage) {
          await expect(validationMessage).toBeInTheDocument();
        }
        
        // Fix the validation
        await userEvent.type(input, 'Valid input');
      }
    }
  }
};
```

**For Clarity Component Combinations:**
```typescript
export const ClarityComponentFlow: Story = {
  ...Default,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Handle Clarity Button + Input combinations
    const clrButtons = canvasElement.querySelectorAll('clr-button, [clr-button]');
    const clrInputs = canvasElement.querySelectorAll('clr-input, clr-textarea, clr-select');
    
    // Fill all Clarity inputs first
    for (const input of clrInputs) {
      const actualInput = input.querySelector('input, textarea, select');
      if (actualInput && !actualInput.disabled) {
        await userEvent.clear(actualInput);
        
        if (actualInput.type === 'email') {
          await userEvent.type(actualInput, 'test@example.com');
        } else if (actualInput.type === 'password') {
          await userEvent.type(actualInput, 'password123');
        } else if (actualInput.type === 'number') {
          await userEvent.type(actualInput, '42');
        } else {
          await userEvent.type(actualInput, 'Test input');
        }
      }
    }
    
    // Then interact with Clarity buttons
    for (const clrButton of clrButtons) {
      const actualButton = clrButton.querySelector('button') || clrButton;
      if (actualButton instanceof HTMLButtonElement && !actualButton.disabled) {
        await userEvent.click(actualButton);
      }
    }
  }
};

export const ClarityModalFlow: Story = {
  ...Default,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Handle Clarity Modal interactions
    const modalTrigger = canvasElement.querySelector('[clr-modal-trigger], .modal-trigger');
    if (modalTrigger instanceof HTMLElement) {
      await userEvent.click(modalTrigger);
      
      // Wait for modal to appear
      const modal = canvasElement.querySelector('clr-modal, .modal');
      if (modal) {
        // Fill form inside modal if exists
        const modalInputs = modal.querySelectorAll('input, textarea, select');
        for (const input of modalInputs) {
          if (input instanceof HTMLInputElement && input.type === 'text') {
            await userEvent.type(input, 'Modal input');
          }
        }
        
        // Click modal action buttons
        const modalButtons = modal.querySelectorAll('button');
        const submitButton = Array.from(modalButtons).find(btn => 
          btn.textContent?.includes('Submit') || btn.textContent?.includes('确认')
        );
        
        if (submitButton instanceof HTMLButtonElement) {
          await userEvent.click(submitButton);
        }
      }
    }
  }
};
```

#### For Modal/Dialog Components
```typescript
export const OpenModal: Story = {
  ...Default,
  args: {
    ...Default.args,
    isOpen: true
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Test modal interactions
    const closeButton = canvas.getByLabelText(/close/i);
    await userEvent.click(closeButton);
  }
};

export const ModalWithForm: Story = {
  ...Default,
  args: {
    ...Default.args,
    isOpen: true
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Fill form in modal
    const nameInput = canvas.getByLabelText(/name/i);
    const submitButton = canvas.getByRole('button', { name: /submit/i });
    
    await userEvent.type(nameInput, 'John Doe');
    await userEvent.click(submitButton);
  }
};
```

### Step 5: Advanced Story Patterns

#### Data-driven Stories
```typescript
export const WithDifferentData: Story = {
  ...Default,
  args: {
    ...Default.args,
    items: [
      { id: 1, name: 'Item 1', status: 'active' },
      { id: 2, name: 'Item 2', status: 'inactive' },
      { id: 3, name: 'Item 3', status: 'pending' }
    ]
  }
};

export const EmptyState: Story = {
  ...Default,
  args: {
    ...Default.args,
    items: []
  }
};

export const LoadingState: Story = {
  ...Default,
  args: {
    ...Default.args,
    loading: true,
    items: []
  }
};
```


## Auto-Generation Rules

### Template Optimization Best Practices

#### Common Template in Decorators
When most stories use the same component template, define it in meta decorators to eliminate code duplication:

```typescript
// ✅ Best Practice - Template in decorator
const meta: Meta<ComponentType> = {
  decorators: [
    moduleMetadata({ /* module config */ }),
    (storyFn) => {
      const story = storyFn();
      return {
        ...story,
        template: `
          <component-selector
            [input1]="input1"
            [input2]="input2"
            (output1)="output1($event)"
            (output2)="output2($event)">
          </component-selector>
        `,
      };
    },
  ],
  // ... other meta config
};

// Stories only need args (much cleaner)
export const Default: Story = {
  args: { input1: 'value', input2: false },
};

export const Variant: Story = {
  args: { input1: 'different', input2: true },
};

// Override template only when needed
export const CustomLayout: Story = {
  args: { input1: 'custom', input2: false },
  render: (args) => ({
    props: args,
    template: `
      <div class="special-wrapper">
        <component-selector [input1]="input1" [input2]="input2"></component-selector>
      </div>
    `,
  }),
};
```

#### Template Generation Logic
```typescript
// Auto-generate template bindings from component analysis
function generateTemplate(component: ComponentAnalysis): string {
  const inputs = component.inputs
    .map(input => `[${input.name}]="${input.name}"`)
    .join('\n            ');
  
  const outputs = component.outputs
    .map(output => `(${output.name})="${output.name}($event)"`)
    .join('\n            ');
  
  return `
    <${component.selector}
      ${inputs}
      ${outputs}>
    </${component.selector}>
  `;
}
```

### Non-Standalone Component Rules

#### Module Detection and Import Logic
```typescript
// ✅ Angular 19: Components are standalone by default
// 1. Detect component standalone status - only non-standalone if explicitly declared
const isStandalone = !componentSource.includes('standalone: false');

// 2. For non-standalone components, identify required modules
if (!isStandalone) {
  const requiredModules = ['CommonModule']; // Always include CommonModule
  
  // Check for Clarity UI usage (most common in this project)
  if (templateHasClarityComponents(['clr-', 'cds-icon', 'clr-input'])) {
    requiredModules.push('ClarityModule');
  }
  
  // ✅ Check for Transloco usage - use project mock system
  if (templateHasTransloco(['*transloco', 't('])) {
    // Don't add direct TranslocoModule - use project's SdkI18nModule
    requiredModules.push('TranslocoModule');
    
  }
  
  // Check for form directives
  if (templateHasFormDirectives(['formControl', 'ngModel', 'formGroup'])) {
    requiredModules.push('ReactiveFormsModule', 'FormsModule');
  }
}

// ✅ Path calculation utility
function calculateRelativePathToStorybookBase(componentPath: string): string {
  // From component path to project root, then to .storybook-base
  const depth = componentPath.split('/').length - 1;
  const upLevels = '../'.repeat(depth);
  return `${upLevels}.storybook-base`;
}

// ✅ Enhanced template analysis
function templateHasTransloco(templateContent: string): boolean {
  const patterns = [
    /\*transloco\s*=\s*["']let\s+\w+["']/,  // *transloco="let t"
    /t\(['"`][^'"`]*['"`]\)/,               // t('key')
    /\{\{\s*.*t\(['"`][^'"`]*['"`]\).*\}\}/ // {{ t('key') }}
  ];
  return patterns.some(pattern => pattern.test(templateContent));
}

function templateHasClarityComponents(templateContent: string): boolean {
  const clarityPatterns = [
    /<clr-\w+/,           // <clr-button>, <clr-input>, etc.
    /<cds-icon/,          // <cds-icon>
    /clr\w+/,             // clrButton directive
    /\[clr-\w+\]/         // [clr-modal-trigger]
  ];
  return clarityPatterns.some(pattern => pattern.test(templateContent));
}
```

#### Service Dependency Injection
```typescript
// 1. Parse constructor dependencies
const serviceDependencies = parseConstructorServices(componentSource);

// 2. Check existing providers in .storybook-base/preview.ts
const existingProviders = parseApplicationConfig('.storybook-base/preview.ts');

// 3. Create mock services for missing dependencies
serviceDependencies.forEach(service => {
  if (!existingProviders.includes(service.name)) {
    createMockService(service);
    updatePreviewProviders(service);
  }
});

// 4. Mock service creation pattern
function createMockService(service) {
  const mockFileName = `.storybook-base/mock/${service.kebabCase}.mock.ts`;
  const mockClass = generateMockClass(service);
  writeFile(mockFileName, mockClass);
  updateMockIndex(service);
}
```

#### Component Args Synchronization
```typescript
// Ensure args exactly match component @Input() and @Output() properties
const componentInterface = parseComponentInterface(componentSource);

const autoGeneratedArgs = {
  // For each @Input() property
  ...componentInterface.inputs.reduce((acc, input) => {
    acc[input.name] = generateMockValue(input.type, input.name);
    return acc;
  }, {}),
  
  // For each @Output() event
  ...componentInterface.outputs.reduce((acc, output) => {
    acc[output.name] = action(output.name);
    return acc;
  }, {})
};
```

#### Translation Parameters Generation
```typescript
// Auto-generate translation parameters based on template analysis
function generateStoryParameters(componentTemplate: string): { translations?: Record<string, string> } {
  if (!hasTranslocoUsage(componentTemplate)) {
    // ✅ No transloco usage - return empty parameters
    return {};
  }
  
  // Component uses transloco - generate translation parameters
  const translationKeys = analyzeTranslationKeys(componentTemplate);
  const translations: Record<string, string> = {};
  
  translationKeys.forEach(key => {
    translations[key] = generateDefaultTranslation(key);
  });
  
  return { translations };
}

// Conditional parameter generation
function generateParametersSection(componentTemplate: string): string {
  if (hasTranslocoUsage(componentTemplate)) {
    return `,
    // ✅ Auto-generated translations based on template analysis
    translations: {
      [AUTO_GENERATED_TRANSLATIONS]
    }`;
  }
  
  return ''; // No translations parameter needed
}

// Integration with existing preview.ts architecture:
// - If translations exist: context.parameters['translations'] → mockTranslocoService.addTranslations()
// - If no translations: MockTranslocoService uses default empty state
```

### HTML Template Analysis & Component Type Detection

#### Template Parsing Strategy
1. **Parse HTML Template**: Analyze the component's template file (.html)
2. **Element Detection**: Identify interactive elements using CSS selectors
3. **Attribute Analysis**: Check for Angular directives and HTML attributes
4. **Content Analysis**: Examine element content and structure

#### Interactive Element Categories

**Button Elements:**
- Standard: `<button>`, `<input type="button|submit|reset">`
- Clarity: `<clr-button>`, `[clr-button]`, `<clr-icon-button>`
- Custom: `[role="button"]`, elements with `(click)` handlers
- Action triggers: `[clr-modal-trigger]`, `[clr-dropdown-trigger]`

**Input Elements:**
- Text inputs: `<input type="text|email|password|search|url">`, `<textarea>`
- Numbers: `<input type="number|range">`
- Selections: `<select>`, `<input type="radio|checkbox">`
- Dates: `<input type="date|time|datetime-local">`
- Files: `<input type="file">`
- Clarity inputs: `<clr-input>`, `<clr-textarea>`, `<clr-select>`, `<clr-checkbox>`, `<clr-radio>`, `<clr-datepicker>`, `<clr-combobox>`

**Complex Components:**
- Forms: `<form>`, `<clr-form>`, containers with multiple inputs
- Modals: `<clr-modal>`, `<clr-wizard>`, `[clr-modal]`
- Data displays: `<clr-datagrid>`, `<clr-tree>`, `<clr-accordion>`
- Navigation: `<clr-tabs>`, `<clr-stepper>`, `<clr-vertical-nav>`

#### Auto-Story Generation Logic
```typescript
// Template analysis results determine story generation:
const templateAnalysis = {
  hasButtons: ['<button>', '<clr-button>', '(click)'].some(exists),
  hasInputs: ['<input>', '<clr-input>', 'formControl'].some(exists),
  hasForm: ['<form>', '<clr-form>', 'ngForm'].some(exists),
  hasModal: ['<clr-modal>', '[clr-modal]'].some(exists),
  hasDatagrid: ['<clr-datagrid>'].some(exists),
  // ... other element types
};

// Generate stories based on detected elements with type safety
if (templateAnalysis.hasButtons) generateButtonStories();
if (templateAnalysis.hasInputs) generateInputStories();
if (templateAnalysis.hasForm) generateFormStories();
if (templateAnalysis.hasModal) generateModalStories();

// Best practices for element selection:
// 1. Use canvasElement.querySelector() for direct DOM access
// 2. Use canvas.getByRole() for accessibility-based queries
// 3. Add type checks: element instanceof HTMLButtonElement
// 4. Check disabled state before interactions
```

### Story Generation Strategy
```typescript
// Base stories (always generated)
- Default: Basic component with default props
- [ComponentType]Variants: Different visual states

// Interactive stories (conditional based on component type)
- UserInteractions: For components with buttons/inputs
- ValidationStates: For form components
- LoadingStates: For async components
- ErrorStates: For components with error handling
- EmptyStates: For data display components

// Advanced stories (optional based on complexity)
- PerformanceTests: For data-heavy components
```

### Auto-Generated Controls
```typescript
// Type mapping for controls
const controlMap = {
  'string': { control: 'text' },
  'number': { control: 'number' },
  'boolean': { control: 'boolean' },
  'Date': { control: 'date' },
  "'small' | 'medium' | 'large'": { 
    control: 'select', 
    options: ['small', 'medium', 'large'] 
  },
  'Array<T>': { control: 'object' },
  'object': { control: 'object' },
  'Function': { control: false } // Hide function props
};
```

## HTML Template Analysis Examples

### Example 1: Complex Login Form Component
```html
<!-- login.component.html -->
<clr-form>
  <clr-input-container>
    <label>Username</label>
    <input clrInput type="email" [(ngModel)]="username" required />
    <clr-control-error>Username is required</clr-control-error>
  </clr-input-container>
  
  <clr-password-container>
    <label>Password</label>
    <input clrPassword [(ngModel)]="password" required />
    <clr-control-error>Password is required</clr-control-error>
  </clr-password-container>
  
  <clr-checkbox-wrapper>
    <input type="checkbox" clrCheckbox [(ngModel)]="rememberMe" />
    <label>Remember me</label>
  </clr-checkbox-wrapper>
  
  <div class="btn-group">
    <button type="submit" class="btn btn-primary" (click)="onLogin()">Login</button>
    <button type="button" class="btn btn-outline" (click)="onCancel()">Cancel</button>
  </div>
</clr-form>
```

**Generated Stories for Above Template:**
```typescript
// Auto-detected elements: 2 inputs, 1 checkbox, 2 buttons, 1 form
export const LoginFormInteractions: Story = {
  ...Default,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Fill username (email input)
    const usernameInput = canvas.getByLabelText(/username/i);
    await userEvent.type(usernameInput, 'test@example.com');
    
    // Fill password
    const passwordInput = canvas.getByLabelText(/password/i);
    await userEvent.type(passwordInput, 'password123');
    
    // Check remember me
    const rememberCheckbox = canvas.getByLabelText(/remember me/i);
    await userEvent.click(rememberCheckbox);
    
    // Click login button
    const loginButton = canvas.getByRole('button', { name: /login/i });
    await userEvent.click(loginButton);
  }
};

export const FormValidationFlow: Story = {
  ...Default,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Try to submit empty form
    const loginButton = canvas.getByRole('button', { name: /login/i });
    await userEvent.click(loginButton);
    
    // Check validation errors appear
    await expect(canvas.getByText(/username is required/i)).toBeInTheDocument();
    await expect(canvas.getByText(/password is required/i)).toBeInTheDocument();
    
    // Fix validation errors
    await userEvent.type(canvas.getByLabelText(/username/i), 'valid@email.com');
    await userEvent.type(canvas.getByLabelText(/password/i), 'validpassword');
    
    // Submit again
    await userEvent.click(loginButton);
  }
};

export const CancelFlow: Story = {
  ...Default,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Fill some data
    await userEvent.type(canvas.getByLabelText(/username/i), 'partial@email.com');
    
    // Click cancel
    const cancelButton = canvas.getByRole('button', { name: /cancel/i });
    await userEvent.click(cancelButton);
  }
};
```

### Example 2: Data Management Component
```html
<!-- user-management.component.html -->
<clr-datagrid>
  <clr-dg-column>Name</clr-dg-column>
  <clr-dg-column>Email</clr-dg-column>
  <clr-dg-column>Actions</clr-dg-column>
  
  <clr-dg-row *ngFor="let user of users">
    <clr-dg-cell>{{user.name}}</clr-dg-cell>
    <clr-dg-cell>{{user.email}}</clr-dg-cell>
    <clr-dg-cell>
      <clr-icon-button (click)="editUser(user)" clrTooltip="Edit">
        <clr-icon shape="edit"></clr-icon>
      </clr-icon-button>
      <clr-icon-button (click)="deleteUser(user)" clrTooltip="Delete">
        <clr-icon shape="trash"></clr-icon>
      </clr-icon-button>
    </clr-dg-cell>
  </clr-dg-row>
</clr-datagrid>

<button class="btn btn-primary" (click)="openAddModal()">Add User</button>
```

**Generated Stories:**
```typescript
// Auto-detected: 1 datagrid, multiple icon buttons, 1 add button
export const DatagridInteractions: Story = {
  ...Default,
  args: {
    users: [
      { id: 1, name: 'John Doe', email: 'john@example.com' },
      { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
    ]
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    
    // Test edit button on first row
    const editButtons = canvas.getAllByLabelText(/edit/i);
    if (editButtons[0] instanceof HTMLButtonElement) {
      await userEvent.click(editButtons[0]);
    }
    
    // Test delete button
    const deleteButtons = canvas.getAllByLabelText(/delete/i);
    if (deleteButtons[0] instanceof HTMLButtonElement) {
      await userEvent.click(deleteButtons[0]);
    }
    
    // Test add user button
    const addButton = canvas.getByRole('button', { name: /add user/i });
    if (addButton instanceof HTMLButtonElement) {
      await userEvent.click(addButton);
    }
  }
};

export const EmptyDatagrid: Story = {
  ...Default,
  args: {
    users: []
  }
};
```

## Template Examples

### Simple Button Component Story
```typescript
export const ButtonStories = {
  Default: { args: { text: 'Click me' } },
  Primary: { args: { text: 'Primary', variant: 'primary' } },
  Secondary: { args: { text: 'Secondary', variant: 'secondary' } },
  Disabled: { args: { text: 'Disabled', disabled: true } },
  Loading: { args: { text: 'Loading...', loading: true } },
  WithIcon: { args: { text: 'With Icon', icon: 'user' } }
};
```

### Complex Form Component Story
```typescript
export const FormStories = {
  Default: { args: { mode: 'create' } },
  EditMode: { args: { mode: 'edit', initialData: sampleData } },
  WithValidation: { /* validation interactions */ },
  SubmissionFlow: { /* complete form submission test */ },
  ErrorHandling: { /* error state testing */ }
};
```

### Storybook Decorators Best Practices
```typescript
// ✅ Correct decorator syntax (Method 1 - Direct function call)
decorators: [
  (story) => ({
    template: `<div style="width: 400px; padding: 20px;">${story().template}</div>`,
    moduleMetadata: {
      imports: [ReactiveFormsModule]
    },
    props: story().props
  })
]

// ✅ Correct decorator syntax (Method 2 - Story function approach)
decorators: [
  (storyFn) => {
    const story = storyFn();
    return {
      ...story,
      template: `<div style="padding: 20px;">${story.template}</div>`,
      props: {
        ...story.props
      }
    }
  }
]

// ❌ Incorrect - missing function call
decorators: [
  (story) => ({
    template: `<div>${story.template}</div>`, // Missing ()
    props: story.props // Missing ()
  })
]
```

### Complex Render Functions
```typescript
// ✅ Correct - FormControl created in render function
export const InFormContext: Story = {
  render: (args) => {
    const usernameControl = new FormControl('', [Validators.required]);
    const emailControl = new FormControl('', [Validators.required, Validators.email]);
    const passwordControl = new FormControl('', [Validators.required, Validators.minLength(8)]);

    return {
      props: {
        ...args,
        usernameControl,
        emailControl,
        passwordControl,
      },
      template: `
        <form style="max-width: 400px;">
          <app-form-field [control]="usernameControl"></app-form-field>
          <app-form-field [control]="emailControl"></app-form-field>
          <app-form-field [control]="passwordControl"></app-form-field>
        </form>
      `,
      moduleMetadata: {
        imports: [ReactiveFormsModule],
      },
    }
  }
};

// ❌ Incorrect - FormControl in args (causes initialization issues)
export const InFormContext: Story = {
  render: (args) => ({
    props: args,
    template: `<form>...</form>`
  }),
  args: {
    usernameControl: new FormControl('', [Validators.required]) // Problem: created at module level
  }
};
```

## Usage Examples

### Trigger Commands
```
Create story for LoginComponent
Generate stories for apps/my-app/src/components/button/button.component.ts
Auto-generate stories for UserFormComponent with interactions
```

### Generated File Structure
```
components/
  button/
    button.component.ts
    button.component.stories.ts  // 🔄 Auto-generated
  form/
    user-form.component.ts
    user-form.component.stories.ts  // 🔄 Auto-generated
```

## Advanced Features

### Mock Data Generation
```typescript
// Auto-generate realistic mock data based on prop types
const mockUserData = {
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  avatar: 'https://via.placeholder.com/150',
  role: 'admin'
};
```

## Code Quality Best Practices

### Universal Element Selection Best Practices

These element selection guidelines apply to **all components** (both standalone and non-standalone):

#### Data Test ID Selection
For elements with `data-test-id` attributes, use proper CSS selectors:

```typescript
// ❌ Bad - Wrong data attribute format
const eventList = canvas.getByTestId('event-list'); // Looks for [data-testid="event-list"]

// ✅ Good - Use CSS selector for custom data attributes
const eventList = canvasElement.querySelector('[data-test-id="event-list"]'); // Matches data-test-id
```

#### Element Selection Priority Order
1. **CSS Selectors for custom attributes**: `canvasElement.querySelector('[data-test-id="custom-id"]')`
2. **Semantic roles**: `canvas.getByRole('button', { name: /submit/i })`
3. **Form labels**: `canvas.getByLabelText(/username/i)`
4. **Element structure**: `canvasElement.querySelector('clr-datagrid')`
5. **Avoid text content**: Never use `getByText()` for transloco content

#### Common Element Selection Examples
```typescript
// ✅ Data test IDs (preferred for reliability)
const filterInput = canvasElement.querySelector('[data-test-id="cci-filter-input"]');
const addButton = canvasElement.querySelector('[data-test-id="add-btn"]');
const listItem = canvasElement.querySelector('[data-test-id="list-item"]');

// ✅ Semantic roles (good for accessibility testing)
const button = canvas.getByRole('button');
const textbox = canvas.getByRole('textbox');
const heading = canvas.getByRole('heading', { level: 2 });

// ✅ Form elements (when associated with labels)
const emailInput = canvas.getByLabelText(/email/i);
const passwordInput = canvas.getByLabelText(/password/i);

// ✅ Element structure (for library components)
const clarityModal = canvasElement.querySelector('clr-modal');
const clarityDatagrid = canvasElement.querySelector('clr-datagrid');
const cdsIcon = canvasElement.querySelector('cds-icon[shape="search"]');
```

### Element Selection for Non-Standalone Components

#### Transloco Text Content Selection
For components using *transloco="let t" and t() function calls, avoid text-based selectors:

```typescript
// ❌ Bad - Don't use text content for transloco elements
const title = canvas.getByText('Events List'); // This text is dynamic based on translation

// ✅ Good - Use structural selectors instead
const titleElement = canvasElement.querySelector('h4'); // Select by element type
const titleElement = canvasElement.querySelector('[data-test-id="events-title"]'); // Use data attributes
const titleElement = canvas.getByRole('heading', { level: 4 }); // Use semantic roles
```

### Type Safety in Stories
Always add type checks when interacting with DOM elements:

```typescript
// ✅ Good - Type safe
const button = canvas.getByRole('button');
if (button instanceof HTMLButtonElement && !button.disabled) {
  await userEvent.click(button);
}

// ❌ Bad - No type checking
const button = canvas.getByRole('button');
if (!button.disabled) {
  await userEvent.click(button);
}
```

## Translation Best Practices

### Translation Parameters Integration

The `.storybook-base/preview.ts` already includes a decorator that automatically applies translation parameters:

```typescript
// preview.ts decorator automatically handles this
const translocoService = mockTranslocoService;
translocoService.setActiveLang(context.globals['language']);
if (context.parameters['translations']) {
  translocoService.addTranslations(context.parameters['translations']);
}
```

**Workflow:**
1. **Template Analysis**: Parse component template for `*transloco` directive and `t('key')` patterns
2. **Conditional Check**: Only proceed if transloco usage is detected
3. **Auto-Generate**: Create `parameters.translations` mapping (only if needed)
4. **Global Integration**: Preview.ts automatically applies translations to MockTranslocoService
5. **Language Support**: Global toolbar allows switching between `en`, `fr`, `es`

### Translation Key Detection Patterns
```typescript
// Supported patterns for automatic detection:
*transloco="let t"                           // ✅ Transloco directive  
{{ t('sdk.label.type') }}                    // ✅ Interpolation
[placeholder]="t('sdk.text.placeholder')"    // ✅ Attribute binding  
<h4>{{ t('sdkUI.eventList.title') }}</h4>    // ✅ Element content
*ngIf="items.length === 0" {{ t('sdk.text.noItems') }}  // ✅ Conditional
{{ placeholder || t('sdk.text.filterPlaceholder') }}    // ✅ Fallback pattern
```

### Translation Testing Best Practices

#### MockTranslocoService Language Suffix Handling
```typescript
// ⚠️ Important: MockTranslocoService automatically adds language suffixes
// - English: "Filter..." → "Filter... [EN]"  
// - French: "Filter..." → "Filter... [FR]"
// - Spanish: "Filter..." → "Filter... [ES]"

// ✅ Flexible testing for translated content
export const Default: Story = {
  args: { placeholder: '' }, // Empty - triggers translation
  play: async ({ canvasElement }) => {
    const input = canvasElement.querySelector('[data-test-id="input"]');
    if (input instanceof HTMLInputElement) {
      const placeholder = input.getAttribute('placeholder');
      // Use regex to handle language suffix
      await expect(placeholder).toMatch(/^Filter\.\.\./);
    }
  }
};

// ✅ Exact testing for custom content  
export const WithCustomPlaceholder: Story = {
  args: { placeholder: 'Search products...' }, // Custom - no translation
  play: async ({ canvasElement }) => {
    const input = canvasElement.querySelector('[data-test-id="input"]');
    if (input instanceof HTMLInputElement) {
      // Custom values are used exactly as provided
      await expect(input).toHaveAttribute('placeholder', 'Search products...');
    }
  }
};
```

#### Conditional Logic in Templates
```typescript
// Template pattern: {{ placeholder || t('translation.key') }}
// Logic: If placeholder exists → use it, else → call translation

function generateTranslationTestStrategy(templateContent: string): string {
  const hasFallbackPattern = /\{\{\s*\w+\s*\|\|\s*t\(['"`][^'"`]*['"`]\)\s*\}\}/.test(templateContent);
  
  if (hasFallbackPattern) {
    return `
    // ✅ Test both translation and custom value scenarios
    
    // Translation scenario (empty custom value)
    const placeholder = input.getAttribute('placeholder');
    await expect(placeholder).toMatch(/^[EXPECTED_TRANSLATION]/);
    
    // Custom value scenario (provided custom value)  
    await expect(input).toHaveAttribute('placeholder', '[CUSTOM_VALUE]');
    `;
  }
  
  return `
    // ✅ Direct translation testing
    await expect(element).toHaveTextContent(/^[EXPECTED_TRANSLATION]/);
  `;
}
```

### Components Without Transloco
```typescript
// Example: Simple component with no internationalization
// Template: <button>{{ label }}</button>
// Result: No parameters.translations generated

const meta: Meta<SimpleButtonComponent> = {
  title: 'Components/SimpleButton',
  component: SimpleButtonComponent,
  parameters: {
    layout: 'centered',
    docs: {
      description: {
        component: 'Simple button component with no translations'
      }
    }
    // ✅ No translations parameter - component doesn't use transloco
  },
  // ... rest of configuration
};
```

### Story-Specific Translation Overrides
```typescript
// Individual stories can override or extend translations
export const CustomTranslations: StoryObj<MyComponent> = {
  args: { /* ... */ },
  parameters: {
    translations: {
      // Extend base translations
      'sdk.label.customField': 'Custom Field Label',
      'component.specific.message': 'Component-specific message'
    }
  }
};
```

### Multi-Language Testing Strategy
```typescript
// Language-specific stories for comprehensive testing
export const EnglishDefault: StoryObj<MyComponent> = {
  args: { /* ... */ },
  parameters: { translations: baseTranslations }
};

export const FrenchLocalization: StoryObj<MyComponent> = {
  args: { /* ... */ },
  parameters: { 
    translations: {
      ...baseTranslations,
      'sdk.label.type': 'Type',  // MockTranslocoService will auto-append [FR] when language is 'fr'
      'sdk.label.status': 'Statut'
    }
  },
  play: async ({ canvasElement }) => {
    // Verify French translations appear correctly with [FR] suffix
    const typeLabel = canvasElement.querySelector('[data-test-id="type-label"]');
    await expect(typeLabel).toHaveTextContent(/Type \[FR\]/);
  }
};
```

### Element Selection Best Practices
Use the appropriate method for element selection:

```typescript
// For direct DOM access (Clarity components)
const spinner = canvasElement.querySelector('clr-spinner');
const clrButtons = canvasElement.querySelectorAll('clr-button');

// For accessibility-based queries (semantic elements)
const button = canvas.getByRole('button');
const textInput = canvas.getByLabelText(/username/i);

// For testing library queries
const canvas = within(canvasElement);
```

### Input Type Safety
Add type guards for input elements:

```typescript
const input = canvas.getByLabelText(/email/i);
if (input instanceof HTMLInputElement) {
  await userEvent.type(input, 'test@example.com');
  await expect(input).toHaveValue('test@example.com');
}
```

### Error Prevention
Always check element existence and state:

```typescript
// Check if element exists and is correct type
const modalTrigger = canvasElement.querySelector('[clr-modal-trigger]');
if (modalTrigger instanceof HTMLElement) {
  await userEvent.click(modalTrigger);
}

// Check disabled state before interaction
if (button instanceof HTMLButtonElement && !button.disabled) {
  await userEvent.click(button);
}
```

### Storybook Syntax Corrections

#### Decorator Function Calls and Template Optimization
Always call story functions in decorators and use common templates to reduce duplication:

```typescript
// ✅ Best Practice - Common template in decorator (Recommended)
decorators: [
  moduleMetadata({ imports: [CommonModule] }),
  (storyFn) => {
    const story = storyFn();
    return {
      ...story,
      template: `
        <my-component
          [prop1]="prop1"
          [prop2]="prop2"
          (event1)="event1($event)"
          (event2)="event2($event)">
        </my-component>
      `,
    };
  },
]

// Stories become much cleaner
export const Default: Story = {
  args: { prop1: 'value', prop2: false },
};

// ✅ Correct - call story() function (Alternative Method)
decorators: [
  (story) => ({
    template: `<div>${story().template}</div>`,
    props: story().props,
    moduleMetadata: { imports: [SomeModule] }
  })
]

// ✅ Override template only when needed
export const CustomLayout: Story = {
  args: { prop1: 'custom' },
  render: (args) => ({
    props: args,
    template: `
      <div class="wrapper">
        <my-component [prop1]="prop1"></my-component>
      </div>
    `,
  }),
};

// ❌ Incorrect - missing function calls
decorators: [
  (story) => ({
    template: `<div>${story.template}</div>`, // Missing ()
    props: story.props // Missing ()
  })
]

// ❌ Inefficient - repetitive templates in every story
export const Story1: Story = {
  render: (args) => ({
    props: args,
    template: `<my-component [prop1]="prop1" [prop2]="prop2"></my-component>` // Repeated
  })
};

export const Story2: Story = {
  render: (args) => ({
    props: args,
    template: `<my-component [prop1]="prop1" [prop2]="prop2"></my-component>` // Repeated again
  })
};
```

#### Action Configuration for Events
Properly configure actions for @Output() events:

```typescript
// ✅ Correct - Configure actions in both argTypes and args
const meta: Meta<ComponentType> = {
  argTypes: {
    // Configure action in argTypes for automatic detection
    primaryClick: {
      action: 'primaryClick'
    },
    secondaryClick: {
      action: 'secondaryClick'
    }
  },
  args: {
    // Also bind action handlers in args
    primaryClick: action('primaryClick'),
    secondaryClick: action('secondaryClick')
  }
};

// ❌ Incorrect - only args without argTypes action config
const meta: Meta<ComponentType> = {
  args: {
    primaryClick: action('primaryClick'), // Actions may not be captured
    secondaryClick: action('secondaryClick')
  }
};
```

#### Default Args Configuration
Include meaningful default values in args:

```typescript
// ✅ Correct - Include default values for better story display
const meta: Meta<ModalComponent> = {
  args: {
    title: 'Sample Modal',
    primaryButtonText: 'Confirm',
    secondaryButtonText: 'Cancel',
    isOpen: true, // Default to open for better visualization
    primaryClick: action('primaryClick'),
    secondaryClick: action('secondaryClick')
  }
};

// ❌ Incorrect - Empty or minimal args
const meta: Meta<ModalComponent> = {
  args: {
    primaryClick: action('primaryClick'),
    secondaryClick: action('secondaryClick')
    // Missing default values for better UX
  }
};
```

#### Render Function Best Practices
Create complex objects inside render functions, not in args:

```typescript
// ✅ Correct - FormControl created in render function
export const WithFormControls: Story = {
  render: (args) => {
    const control = new FormControl('', [Validators.required]);
    return {
      props: { ...args, control },
      template: `<app-component [control]="control"></app-component>`
    };
  }
};

// ❌ Incorrect - FormControl in args (module-level instantiation)
export const WithFormControls: Story = {
  args: {
    control: new FormControl('', [Validators.required]) // Problem!
  }
};
```

#### Module Imports in Custom Renders
Always include necessary imports when using custom templates:

```typescript
// ✅ Correct - includes moduleMetadata
render: (args) => ({
  props: args,
  template: `<custom-template>...</custom-template>`,
  moduleMetadata: {
    imports: [ReactiveFormsModule, CustomModule]
  }
})

// ❌ Incorrect - missing required imports
render: (args) => ({
  props: args,
  template: `<custom-template>...</custom-template>`
  // Missing moduleMetadata
})
```
## Complete Translation Integration Example


### Project-Specific Optimizations

1. **Dependency Management**: Always use project's mock system instead of external packages
2. **Layout Consistency**: Standardize wrapper styles and layout parameters
3. **Test Robustness**: Handle MockTranslocoService language suffixes gracefully
4. **Path Calculation**: Automate relative path calculation for consistent imports
5. **Documentation Control**: Comment out autodocs by default, enable per project needs
6. **Element Selection**: Prioritize `[data-test-id]` for transloco-safe testing
7. **Story Structure**: Limit to 5 focused stories covering key scenarios
8. **Type Safety**: Always include type guards for DOM element interactions
9. **Universal Element Selection**: Use consistent element selection patterns for both standalone and non-standalone components

---

**Note**: This rule analyzes TypeScript component files and automatically generates comprehensive, interactive stories with proper controls, actions, and interaction tests using type-safe best practices. Optimized for **Angular 19** where components are standalone by default, it provides full support for both standalone (default) and non-standalone (explicitly declared `standalone: false`) Angular components with proper module imports, service mocking, transloco-safe element selection, and conditional translation parameter generation (only when components actually use transloco).