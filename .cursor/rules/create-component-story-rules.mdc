---
description: "Automatic story generation for Angular components with controls and interactions"
globs: ["**/*.component.ts", "**/*.stories.ts"]
alwaysApply: false
---

# üé≠ Component Story Auto-Generation Rules

## Auto-Generation Trigger

When user requests "Create story for [component-name]" or "Generate stories for [component-path]", automatically analyze the component and generate comprehensive stories.

## üöÄ Angular 19 Compatibility

**Important**: Components are **standalone by default**. A component is only non-standalone if it explicitly declares `standalone: false`.

## Core Generation Flow

### 1. Component Analysis
Automatically detect:
1. **Standalone status** - Angular 19 default is standalone, only non-standalone if `standalone: false` is explicitly declared
2. **Import statements** - extract all import paths and types from component.ts for accurate type reuse
3. **Dependencies** - analyze HTML/TS for required modules, pipes, services
4. **@Input() properties** - for controls generation with actual types from imports  
5. **@Output() events** - for action handlers with `import { action } from '@storybook/addon-actions'`
6. **Translation usage** - detect `*transloco="let t"` and `t()` calls, extract translation keys for parameters.translations
7. **Service injection** - check constructor for injected services, compare with @storybook-config/preview.ts global providers
   - TranslocoService: Use parameters.translations for i18n content
   - Store (@ngxs/store): Use parameters.storeSelectors/storeReducers for state management
   - Other services: Create local mocks only if not globally provided

### 2. Dependency Analysis & Import Strategy
```typescript
// ‚úÖ Comprehensive Dependency Analysis
function analyzeDependencies(componentSource: string, templateContent: string): {
  imports: string[];
  providers: string[];
  mockTypes: string[];
  unknownComponents: string[];
} {
  const imports = ['CommonModule'];
  const providers = [];
  const mockTypes = [];
  const unknownComponents = [];
  
  // Standalone check
  const isStandalone = !componentSource.includes('standalone: false');
  
  // Clarity UI detection
  if (/clr-|cds-|\[clr|\(clr/.test(templateContent)) {
    imports.push('ClarityModule');
  }
  
  // Transloco detection - critical for component display
  if (/\*transloco\s*=\s*["']let\s+\w+["']|t\(['"`]/.test(templateContent)) {
    imports.push('SdkI18nModule from @storybook-config/mock'); // ‚úÖ Use path aliases
  }
  
  // Custom component detection (non-standard selectors)
  const customComponentMatches = templateContent.match(/<([a-z]+-[a-z\-]+)/g);
  if (customComponentMatches) {
    customComponentMatches.forEach(match => {
      const componentSelector = match.replace('<', '');
      // Skip known framework components
      if (!componentSelector.startsWith('clr-') && 
          !componentSelector.startsWith('cds-') && 
          !componentSelector.startsWith('ng-')) {
        unknownComponents.push(componentSelector);
      }
    });
  }
  
  // Pipe dependencies (prefer real imports, check standalone status)
  const pipeMatches = templateContent.match(/\|\s*(\w+)/g);
  if (pipeMatches) {
    pipeMatches.forEach(pipe => {
      const pipeName = pipe.replace(/\|\s*/, '');
      if (!['date', 'json', 'uppercase', 'lowercase', 'currency'].includes(pipeName)) {
        // ‚úÖ Try real import first: import { SortByPipe } from '../pipes/sort-by.pipe'
        // ‚úÖ Check pipe's standalone status to determine placement:
        // - standalone: true (Angular 19 default) ‚Üí imports: [PipeName]
        // - standalone: false ‚Üí declarations: [PipeName]
        // ‚ùå Avoid complex mocks: only create simple mocks when real import fails
        imports.push(`${pipeName}Pipe from relative path`);
      }
    });
  }
  
  // Service injection analysis - check against global providers
  const constructorMatch = componentSource.match(/constructor\([^)]*\)/);
  if (constructorMatch) {
    const globalServices = ['TranslocoService', 'Store']; // From @storybook-config
    const injectedServices = extractInjectedServices(constructorMatch[0]);
    
    // Determine strategy for each service
    injectedServices.forEach(service => {
      if (service.includes('TranslocoService')) {
        // Use parameters.translations instead of mocking
      } else if (service.includes('Store')) {
        // Use parameters.storeSelectors/storeReducers instead of mocking
      } else {
        // Create local mock for non-global services
        mockTypes.push(`Mock${service}`);
      }
    });
  }
  
  return { imports, providers, mockTypes, unknownComponents };
}
```

### 3. Unknown Component Handling Strategy

```typescript
// ‚úÖ Generate TODO comments for unknown components
function generateUnknownComponentTodos(unknownComponents: string[]): string {
  if (unknownComponents.length === 0) return '';
  
  const todos = unknownComponents.map(selector => {
    const componentName = selector.split('-')
      .map(part => part.charAt(0).toUpperCase() + part.slice(1))
      .join('') + 'Component';
    
    return `// TODO: Import the real ${selector} component
// Example: import { ${componentName} } from '../path/to/${selector}/${selector}.component';
// Then add '${componentName}' to the imports array in moduleMetadata`;
  });
  
  return todos.join('\n');
}

// ‚úÖ Template for unknown component handling
const unknownComponentTemplate = `
// TODO: Import unknown components found in template:
// Components detected: [COMPONENT_SELECTORS]
// 
// For each component:
// 1. Find the actual import path
// 2. Import the component
// 3. Add to moduleMetadata imports (if standalone) or declarations (if non-standalone)
// 4. Update test selectors in play functions based on real component structure
`;
```

### 4. Dependency Strategy (Real Types First)
```typescript
// ‚úÖ Priority Strategy: Real Types > Type-Safe Mocks > Never Any
function analyzeDependencyStrategy(componentSource: string, templateContent: string): {
  realImports: string[];
  standalonePipes: string[];
  nonStandalonePipes: string[];
  mockServices: string[];
  mockData: string[];
} {
  // 1. Import real types from component
  // ‚úÖ Extract types from component imports
  const typeImports = extractImportsFromComponent(componentSource);
  // ‚úÖ Always use component's actual import paths
  
  // 2. Direct import of component-related pipes/services  
  // ‚úÖ Import real implementations when available
  // import { SortByPipe } from '../pipes/sort-by.pipe';
  
  // 3. Analyze pipe standalone status for correct placement
  function analyzePipeStandalone(pipeSource: string): boolean {
    // Angular 19: standalone by default unless explicitly declared false
    return !pipeSource.includes('standalone: false');
  }
  
  // 4. Create type-safe mocks using real types
  // ‚úÖ Use component's actual types for mock data
  function generateTypeSafeMockData(componentInputs: InputProperty[]): string[] {
    return componentInputs.map(input => {
      const inputType = extractInputType(input);
      return `const mock${capitalize(input.name)}: ${inputType} = { /* properties matching ${inputType} */ };`;
    });
  }
  
  // 5. Smart service strategy - check global providers first
  // ‚úÖ Analyze injected services against global providers
  function analyzeServiceStrategy(injectedServices: string[]): ServiceStrategy {
    const globalServices = ['TranslocoService', 'Store']; // From @storybook-config
    const needsLocalMock = injectedServices.filter(service => 
      !globalServices.includes(service.replace(/^.*\./, '')) // Remove namespace
    );
    
    return {
      useGlobalStore: injectedServices.some(s => s.includes('Store')),
      useGlobalTransloco: injectedServices.some(s => s.includes('TranslocoService')),
      needsLocalMocks: needsLocalMock,
    };
  }
  
  // ‚úÖ Generate parameters configuration instead of service mocks
  function generateParametersConfig(componentUsage: ComponentUsage): ParametersConfig {
    const config: ParametersConfig = {};
    
    // Translation keys from template analysis
    if (componentUsage.usesTransloco) {
      config.translations = extractTranslationKeys(componentUsage.template);
    }
    
    // Store selectors and reducers from component analysis
    if (componentUsage.usesStore) {
      config.storeSelectors = analyzeStoreSelectors(componentUsage.storeUsage);
      config.storeReducers = analyzeStoreActions(componentUsage.actionDispatches);
    }
    
    return config;
  }
  
  return { realImports, standalonePipes, nonStandalonePipes, mockServices, mockData };
}

// ‚úÖ Type extraction utilities - extract exact import paths from component
function extractImportsFromComponent(source: string): ImportAnalysis[] {
  const importMatches = source.match(/import\s*{([^}]+)}\s*from\s*['"`]([^'"`]+)['"`]/g);
  return importMatches?.map(match => {
    const [, types, path] = match.match(/import\s*{([^}]+)}\s*from\s*['"`]([^'"`]+)['"`]/) || [];
    return { 
      types: types.split(',').map(t => t.trim()), 
      path: path.trim() // Keep exact path from component
    };
  }) || [];
}

interface ImportAnalysis {
  types: string[];
  path: string; // Exact import path from component.ts
}

// ‚úÖ Generate import statements using component's actual paths
function generateImportStatements(componentImports: ImportAnalysis[]): string[] {
  return componentImports.map(({ types, path }) => 
    `import { ${types.join(', ')} } from '${path}'; // From component's imports`
  );
}

function extractInputType(input: string): string {
  const typeMatch = input.match(/@Input\(\)\s*(\w+)(?::\s*([^;=]+))?/);
  return typeMatch?.[2]?.trim() || 'unknown';
}
```

### 4. Story Template Generation

#### Template Module Strategy
```typescript
// ‚úÖ Module Import Strategy for Custom Templates
function determineModuleStrategy(stories: Story[]): 'global' | 'individual' {
  const storiesWithCustomTemplate = stories.filter(story => story.render);
  const storiesRequiringModules = stories.filter(story => 
    story.render && (
      story.render.template.includes('[(ngModel)]') ||  // FormsModule
      story.render.template.includes('*ngFor') ||        // CommonModule
      story.render.template.includes('clr-')             // ClarityModule
    )
  );
  
  // If majority of stories need modules, add to meta decorators
  if (storiesRequiringModules.length > stories.length / 2) {
    return 'global';
  }
  
  // If only few stories need modules, add to individual stories
  return 'individual';
}

// ‚úÖ Template Module Requirements Analysis
const templateModuleMap = {
  '[(ngModel)]': 'FormsModule',           // Two-way binding
  '[ngModel]': 'FormsModule',             // One-way binding  
  '(ngModelChange)': 'FormsModule',       // Event binding
  '*ngFor': 'CommonModule',               // Structural directives
  '*ngIf': 'CommonModule',                // Structural directives
  'clr-': 'ClarityModule',                // Clarity components
  'cds-': 'ClarityModule',                // Clarity design system
  '*transloco': 'SdkI18nModule',          // Translation
};
```

#### Universal Template (Real Dependencies First Strategy)
```typescript
import type { Meta, StoryObj } from '@storybook/angular';
import { moduleMetadata } from '@storybook/angular';
import { userEvent, within, expect } from '@storybook/test';
import { action } from '@storybook/addon-actions';
import { CommonModule } from '@angular/common';
import { ClarityModule } from '@clr/angular';
import { FormsModule } from '@angular/forms'; // ‚úÖ For ngModel in custom templates
import { SdkI18nModule } from '@storybook-config/mock'; // ‚úÖ Use path aliases
import { [REAL_TYPES] } from '[COMPONENT_IMPORT_PATH]'; // ‚úÖ Use component's actual import paths
import { [REAL_PIPES] } from '../pipes/[pipe-name].pipe'; // ‚úÖ Prefer real pipes
import { [COMPONENT_NAME] } from './[component-file-name]';

// TODO: Import unknown components found in template
// [UNKNOWN_COMPONENT_TODOS]
// Example: import { CciIconLabelComponent } from '../path/to/cci-icon-label/cci-icon-label.component';
// Then:
// 1. Add to imports array in moduleMetadata if standalone
// 2. Add to declarations array if non-standalone  
// 3. Update play function selectors based on real component structure

// ‚úÖ Type-safe mock data using component's actual types
const mock[DATA_NAME]: [REAL_TYPE] = {
  [REQUIRED_PROPERTIES], // All required properties from type definition
  // Optional properties only if used by component
};

// ‚úÖ Only create abstracts for services NOT in global providers
// Check @storybook-config/preview.ts first:
// - TranslocoService: Use parameters.translations
// - Store: Use parameters.storeSelectors/storeReducers
// 
// For other services not globally provided:
abstract class [LOCAL_SERVICE_NAME] {
  abstract [METHOD_SIGNATURES]; // Based on component usage
}

class Mock[LOCAL_SERVICE_NAME] implements [LOCAL_SERVICE_NAME] {
  [TYPED_METHOD_IMPLEMENTATIONS] // Only for non-global services
}

const meta: Meta<[COMPONENT_NAME]> = {
  title: 'Components/[COMPONENT_NAME]',
  component: [COMPONENT_NAME],
  // ‚úÖ Strategy: Only add global decorators if MAJORITY of stories need custom templates
  decorators: [
    moduleMetadata({
      imports: [
        CommonModule, 
        ClarityModule, 
        SdkI18nModule, 
        [STANDALONE_PIPES],
        // TODO: Add unknown standalone components here
        // [UNKNOWN_STANDALONE_COMPONENTS]
      ], // Standard modules + standalone pipes + standalone components
      declarations: [
        [COMPONENT_NAME], 
        [NON_STANDALONE_PIPES],
        // TODO: Add unknown non-standalone components here  
        // [UNKNOWN_NON_STANDALONE_COMPONENTS]
      ], // Non-standalone pipes + non-standalone components
      providers: [
        { provide: [PIPE_TOKEN], useClass: [REAL_PIPE] }, // Constructor-injected pipes
      ],
    }),
  ],
  parameters: {
    layout: 'centered',
    // ‚úÖ For TranslocoService - configure translations (if component uses transloco)
    translations: { [EXTRACTED_TRANSLATION_KEYS] },
    // ‚úÖ For Store service - configure selectors and reducers (if component uses store)
    storeSelectors: [
      {
        selector: [SELECTOR_FROM_COMPONENT],
        initialValue: [INITIAL_VALUE],
      },
    ],
    storeReducers: [
      {
        actionType: [ACTION_TYPE_FROM_COMPONENT],
        selector: [SELECTOR_FROM_COMPONENT],
        handler: (current: [TYPE]) => [LOGIC_BASED_ON_COMPONENT],
      },
    ],
  },
  argTypes: {
    [INPUT_CONTROLS],
    [OUTPUT_ACTIONS]: { action: 'eventName' },
  },
};

export default meta;
type Story = StoryObj<[COMPONENT_NAME]>;

export const Default: Story = {
  args: {
    [PROPERTY]: mock[DATA_NAME], // ‚úÖ Direct assignment with correct typing
    [EVENT_HANDLERS]: action('eventName'),
  },
  play: async ({ canvasElement }) => {
    // TODO: Update selectors based on unknown components structure
    // Use fallback selectors that work with both unknown and known components
    const element = canvasElement.querySelector('[data-test-id="main-element"], [UNKNOWN_COMPONENT_SELECTORS]');
    await expect(element).toBeInTheDocument();
  }
};

// ‚úÖ Individual story with custom template and specific modules
export const WithCustomTemplate: Story = {
  args: {
    [CUSTOM_ARGS],
  },
  decorators: [
    moduleMetadata({
      imports: [CommonModule, FormsModule, [COMPONENT_NAME]], // ‚úÖ Only modules needed for this template
    }),
  ],
  render: (args) => ({
    props: { 
      ...args, 
      customData: mock[DATA_NAME] // ‚úÖ Direct assignment with full type safety
    },
    template: `
      <[COMPONENT_NAME]
        [config]="config"
        [(ngModel)]="customData">  <!-- Requires FormsModule -->
      </[COMPONENT_NAME]>
    `,
  }),
  play: async ({ canvasElement }) => {
    // Wait for ngModel binding
    await new Promise(resolve => setTimeout(resolve, 200));
    
    const element = canvasElement.querySelector('[data-test-id="element"]');
    await expect(element).toBeInTheDocument();
  }
};
```

### 5. Type Safety Requirements

#### **CRITICAL: Never Use `any` Type**
```typescript
// ‚ùå NEVER do this
const mockData: any = { ... };
select(selector: any): any { ... }
dispatch(action: any): void { ... }

// ‚úÖ ALWAYS use proper types
const mockServiceConfig: MfeConfigBaseModel = {
  pathName: 'test-service',
  displayName: 'Test Service',
  // ... all required properties
};

interface Observable<T> {
  subscribe(observer: (value: T) => void): { unsubscribe(): void };
}

class MockStore implements StoreInterface {
  select<T>(selector: unknown): Observable<T> { ... }
  dispatch(action: StoreAction): void { ... }
}
```

#### **Mock Data Type Strategy**
```typescript
// ‚úÖ Step 1: Import component's actual types (use component's exact import paths)
import { MfeConfigBaseModel } from './mfe-config.model'; // Local file path
import { KubernetesResourceType } from '@cci/sdk-utils'; // External module
import { ComponentInterface } from './component-name.component';

// ‚úÖ Step 2: Create type-safe mock data
const mockServiceConfig: MfeConfigBaseModel = {
  // Include ALL required properties from interface
  pathName: 'test-service',
  displayName: 'Test Service',
  remoteName: 'cci_test_service_mfe',
  supportedResourceTypes: [] as KubernetesResourceType[],
  // ... complete implementation
};

// ‚úÖ Step 3: Use proper generics for collections
const mockStorageClasses: NsStorageClass[] = [
  { name: 'standard' }, // Only properties actually used
  { name: 'premium' }
];

// ‚úÖ Step 4: No type assertions needed
args: {
  serviceConfig: mockServiceConfig, // Direct assignment
  storageClasses: mockStorageClasses, // Already correctly typed
}
```

#### **Service Mock Type Strategy**
```typescript
// ‚úÖ Step 1: Create interface based on component usage
interface StoreInterface {
  select<T>(selector: unknown): Observable<T>;
  selectSnapshot<T>(selector: unknown): T;
  dispatch(action: unknown): void;
}

// ‚úÖ Step 2: Create abstract class as injection token
abstract class Store {
  abstract select<T>(selector: unknown): Observable<T>;
  abstract selectSnapshot<T>(selector: unknown): T;
  abstract dispatch(action: unknown): void;
}

// ‚úÖ Step 3: Implement with proper typing
class MockStore implements StoreInterface {
  private state = { showCardError: false };
  
  select<T>(selector: unknown): Observable<T> {
    return {
      subscribe: (callback: (value: T) => void) => {
        callback(this.state.showCardError as T);
        return { unsubscribe: () => {} };
      }
    };
  }
  
  selectSnapshot<T>(selector: unknown): T {
    return 'default-namespace' as T;
  }
  
  dispatch(action: unknown): void {
    // Type-safe action handling
    const actionName = (action as { constructor: { name: string } }).constructor?.name;
    if (actionName === 'ToggleShowCardError') {
      this.state.showCardError = !this.state.showCardError;
    }
  }
}
```

### 6. Story Generation Strategy
```typescript
// ‚úÖ Generate stories based on component's actual functionality
function generateStories(componentAnalysis: ComponentAnalysis): Story[] {
  const stories = [
    // Always generate Default story
    generateDefaultStory(componentAnalysis)
  ];
  
  // Conditional stories based on component features
  if (componentAnalysis.hasInteractions) {
    stories.push(generateInteractiveStory(componentAnalysis));
  }
  
  if (componentAnalysis.hasDataVariations) {
    stories.push(generateDataVariantsStory(componentAnalysis));
  }
  
  if (componentAnalysis.hasStateVariations) {
    stories.push(generateStateVariantsStory(componentAnalysis));
  }
  
  // Avoid redundant stories - each story should test distinct functionality
  return stories;
}

// ‚úÖ Interactive story with userEvent
function generateInteractiveStory(analysis: ComponentAnalysis): Story {
  return {
    name: 'Interactive',
    args: { ...analysis.mockData, ...analysis.actionHandlers },
    play: async ({ canvasElement }) => {
      const canvas = within(canvasElement);
      
      // Use userEvent for realistic user interactions
      const interactiveElement = canvasElement.querySelector('[data-test-id="interactive-element"]');
      if (interactiveElement instanceof HTMLElement) {
        await userEvent.click(interactiveElement);
        // Verify interaction results
      }
    }
  };
}
```

## Element Selection Best Practices

### Priority Order
1. **Data test IDs**: `canvasElement.querySelector('[data-test-id="custom-id"]')`
2. **Semantic roles**: `canvas.getByRole('button', { name: /submit/i })`
3. **Form labels**: `canvas.getByLabelText(/username/i)`
4. **Element structure**: `canvasElement.querySelector('clr-datagrid')`
5. **Avoid text content**: Never use `getByText()` for transloco content

### Angular ng-reflect Attributes
‚ö†Ô∏è **Critical**: Use correct transformed attribute names:

```typescript
// ‚ùå Wrong - Includes component prefix
const columns = canvasElement.querySelectorAll('[ng-reflect-clr-dg-sort-by="severity"]');

// ‚úÖ Correct - Angular transforms [clrDgSortBy] ‚Üí ng-reflect-sort-by
const columns = canvasElement.querySelectorAll('[ng-reflect-sort-by="severity"]');

// Transformation: [clrDgPropertyName] ‚Üí ng-reflect-property-name
// 1. Remove component prefix (clrDg ‚Üí )
// 2. Convert camelCase to kebab-case (sortBy ‚Üí sort-by)
// 3. Add ng-reflect- prefix
```

### Transloco-Safe Selection
```typescript
// ‚ùå Bad - Don't use text content for transloco elements
const title = canvas.getByText('Events List'); // Dynamic translation

// ‚úÖ Good - Use structural selectors
const titleElement = canvasElement.querySelector('h4');
const titleElement = canvasElement.querySelector('[data-test-id="events-title"]');
const titleElement = canvas.getByRole('heading', { level: 4 });
```

## Advanced Story Patterns

### Shared Template Strategy
```typescript
// ‚úÖ When multiple stories need similar templates, use Meta decorators
const meta: Meta<ComponentName> = {
  decorators: [
    moduleMetadata({ /* shared config */ }),
    // Shared template wrapper for multiple stories
    (storyFn, context) => ({
      template: `
        <div class="story-wrapper">
          <h6>{{ context.name }}</h6>
          <ng-container [ngTemplateOutlet]="storyTemplate"></ng-container>
        </div>
        <ng-template #storyTemplate>
          ${storyFn().template}
        </ng-template>
      `,
      props: storyFn().props
    })
  ]
};
```

### Action Integration
```typescript
// ‚úÖ Capture all @Output() events with context
argTypes: {
  storageClassChange: {
    action: 'storageClassChange',
    description: 'Emitted when storage class selection changes'
  }
},

// ‚úÖ In stories
args: {
  storageClassChange: action('storageClassChange')
}
```

### Type Safety
```typescript
// ‚úÖ Always include type guards
const input = canvas.getByLabelText(/email/i);
if (input instanceof HTMLInputElement) {
  await userEvent.type(input, 'test@example.com');
  await expect(input).toHaveValue('test@example.com');
}
```

## Template Module Management

### Smart Module Import Strategy

```typescript
// ‚úÖ Decision Tree for Module Imports
function analyzeTemplateModuleNeeds(stories: Story[]): ModuleStrategy {
  const storiesWithCustomTemplates = stories.filter(s => s.render);
  const moduleRequirements = storiesWithCustomTemplates.map(story => 
    analyzeTemplateModules(story.render.template)
  );
  
  const commonModules = findCommonModules(moduleRequirements);
  const specificModules = findSpecificModules(moduleRequirements);
  
  if (commonModules.length > 0 && storiesWithCustomTemplates.length > stories.length / 2) {
    return {
      strategy: 'global',
      globalModules: commonModules,
      specificStories: specificModules
    };
  }
  
  return {
    strategy: 'individual',
    storyModules: moduleRequirements
  };
}

// ‚úÖ Template analysis patterns
const MODULE_PATTERNS = {
  FormsModule: [
    '[(ngModel)]',     // Two-way binding
    '[ngModel]',       // One-way binding
    '(ngModelChange)', // Model change event
    'ngForm',          // Form directive
    'ngModel'          // Model directive
  ],
  CommonModule: [
    '*ngFor',          // Structural directive
    '*ngIf',           // Structural directive
    '*ngSwitch',       // Structural directive
    '| async',         // Async pipe
    '| json'           // JSON pipe
  ],
  ClarityModule: [
    'clr-',            // Clarity components
    'cds-',            // Clarity design system
    '[clr',            // Clarity directives
    '(clr'             // Clarity events
  ]
};
```

### Implementation Examples





#### Global Module Import
```typescript
// ‚úÖ When majority of stories need same modules
const meta: Meta<ComponentName> = {
  decorators: [
    moduleMetadata({
      imports: [CommonModule, FormsModule, ClarityModule, ComponentName],
    }),
  ],
};

// Individual stories don't need decorators
export const Story1: Story = {
  render: (args) => ({ template: `<component [(ngModel)]="data">` })
};

export const Story2: Story = {
  render: (args) => ({ template: `<component *ngFor="let item of items">` })
};
```

### Best Practices

1. **Analyze Template Requirements**: Check each custom template for module dependencies
2. **Count Usage**: If >50% of stories need same modules, use global import
3. **Minimize Imports**: Only import modules actually used in templates
4. **Performance**: Individual imports are lighter for few stories
5. **Maintainability**: Global imports reduce duplication for many stories

## Translation Testing

### MockTranslocoService Integration
```typescript
// ‚úÖ Use parameters.translations (handled by .storybook-base/preview.ts)
parameters: {
  translations: {
    'sdk.label.type': 'Type',
    'sdk.label.status': 'Status',
    // ... extracted from template analysis
  }
}

// ‚úÖ Test translated content with language suffixes
// MockTranslocoService adds [EN], [FR], [ES] suffixes
await expect(placeholder).toMatch(/^Filter\.\.\./); // Flexible for suffix
await expect(input).toHaveAttribute('placeholder', 'Custom Value'); // Exact for custom
```

## Key Optimizations (Type Safety First Strategy)

1. **Real Types Always**: Import component's actual types from their exact paths, never use `any`
   ```typescript
   // ‚úÖ ALWAYS: Use component's exact import paths
   import { MfeConfigBaseModel } from './mfe-config.model'; // Local path from component
   import { KubernetesResourceType } from '@cci/sdk-utils'; // External from component
   const mockConfig: MfeConfigBaseModel = { /* all required props */ }
   
   // ‚ùå NEVER: Use any type
   const mockConfig: any = { /* props */ }
   const mockConfig = { /* props */ } as any
   ```

2. **Direct Type Assignment**: No type assertions needed with proper typing
   ```typescript
   // ‚úÖ Direct assignment with correct types
   const mockServiceConfig: MfeConfigBaseModel = { pathName: 'test', /* ... */ };
   args: { serviceConfig: mockServiceConfig }
   
   // ‚ùå Avoid type assertions if proper typing is used
   args: { serviceConfig: mockData as MfeConfigBaseModel }
   ```

3. **Smart Service Strategy**: Check global providers first, then configure parameters
   ```typescript
   // ‚úÖ Step 1: Check @storybook-config/preview.ts for global services
   // - TranslocoService: Use parameters.translations for i18n content
   // - Store (@ngxs/store): Use parameters.storeSelectors/storeReducers for state
   
   // ‚úÖ Step 2: For TranslocoService - Configure translations in parameters
   parameters: {
     translations: {
       'sdkUI.errorAlert.serviceNotAvailable': 'Service not available',
       'sdkUI.errorAlert.showError': 'Show Error',
       'sdkUI.errorAlert.hideError': 'Hide Error',
     }
   }
   
   // ‚úÖ Step 3: For Store service - Use global Store with parameters configuration
   parameters: {
     storeSelectors: [
       {
         selector: PublicUserStateSelectors.showCardError,
         initialValue: false,
       },
     ],
     storeReducers: [
       {
         actionType: ToggleShowCardError,
         selector: PublicUserStateSelectors.showCardError,
         handler: (current: boolean) => !current,
       },
     ],
   }
   
   // ‚úÖ Step 4: Only create local mocks for services NOT in global providers
   // Check component injection vs preview.ts providers before mocking
   ```

4. **Minimal Mock Strategy**: Create minimal mocks only when real dependencies are unavailable
5. **Template Module Strategy**: Smart module importing for custom templates
   ```typescript
   // ‚úÖ Individual story approach - only import what's needed
   export const StoryWithNgModel: Story = {
     decorators: [moduleMetadata({ imports: [FormsModule, ComponentName] })],
     render: (args) => ({ template: `<component [(ngModel)]="data">` })
   };
   
   // ‚úÖ Global approach - if majority of stories need same modules
   const meta: Meta = {
     decorators: [moduleMetadata({ imports: [CommonModule, FormsModule] })]
   };
   ```
6. **Action Integration**: Use `@storybook/addon-actions` for all @Output() events  
7. **Transloco Detection**: Critical for component display - detect `*transloco="let t"` patterns
8. **Feature-Based Stories**: Generate stories based on actual functionality, avoid redundancy
9. **UserEvent Integration**: Use userEvent for realistic user interactions

---

**Note**: This rule prioritizes **real dependencies over mocks** to generate accurate, maintainable stories. Optimized for **Angular 19** with path aliases, type assertions, and minimal mock strategy when real dependencies are unavailable.